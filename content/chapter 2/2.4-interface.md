---
title: '2.4 اینترفیس (Interface)'
slug: interface
weight: 3004
---

اینترفیس در زبان گو یک نوع مجموعه ای از متدها می باشد. این مجموعه متدها با توجه به ورودی و خروجی که دارند دارای رفتارهای خاصی هستند. زمانیکه شما یک اینترفیس به همراه یکسری از متدها تعریف می کنید باید در جایی این متدها را پیاده سازی کنید.

اینترفیس ها به شما اجازه می دهد تا از [Duck typing](https://fa.wikipedia.org/wiki/%D9%86%D9%88%D8%B9%E2%80%8C%D8%AF%D9%87%DB%8C_%D8%A7%D8%B1%D8%AF%DA%A9%DB%8C) استفاده کنید. حالا این duck typing چیست؟

duck typing روشی در برنامه نویسی کامپیوتری است که به شما امکان می دهد تست اردک را انجام دهید، جایی که ما نوع را بررسی نمی کنیم، بلکه تنها وجود برخی ویژگی ها یا روش ها را بررسی می کنیم. بنابراین آنچه واقعاً اهمیت دارد این است که آیا یک شی دارای ویژگی ها و روش های خاصی است و نه نوع آن.


برگردیم به بحث اینترفیس, در زیر ما یک نمونه اینترفیس را قرار دادیم :

```go
type name_of_interface interface{
//Method signature 1
//Method signature 2
}
```

برای اینکه مفهوم بالا را بهتر بفهمیم بزارید یک مثال بزنیم ساده بزنیم فرض کنید ما یک شی به نام animal که این حیوان یکسری رفتارها مانند: نفش کشید, راه رفتن را دارد که این رفتارهای باید به یک حیوان اختصاص دهیم تا بتوانیم از رفتارهای آن حیوان را مشخص کنیم.

```go
type animal interface {
    breathe()
    walk()
}
```

در بالا ما یک اینترفیس تعریف کردیم ۲ تا متد دارد حالا بیاید یک متغیر از نوع اینترفیس animal درست کنیم و چاپ کنیم.

```go
package main

import "fmt"

type animal interface {
    breathe()
    walk()
}

func main() {
    var a animal
    fmt.Println(a)
}
```

```shell
$ go run main.go
nil
```

در بالا وقتی اینترفیس را چاپ کردیم و خروجی `nil` بود و توجه کنید اینترفیس مقدار پیش فرض یا خالی بودنش `nil` هست.

## پیاده سازی اینترفیس

در بالا ما یک اینترفیس  animal تعریف کردیم که ۲ متد داشت حالا قصد داریم یک شی (منظور ساختار در گو) به نام lion تعریف کنیم و متدهای اینترفیس animal را پیاده سازی کنیم.

```go
package main

import "fmt"

type animal interface {
    breathe()
    walk()
}

type lion struct {
    age int
}

func (l lion) breathe() {
    fmt.Println("Lion breathes")
}

func (l lion) walk() {
    fmt.Println("Lion walk")
}

func main() {
    var a animal
    a = lion{age: 10}
    a.breathe()
    a.walk()
}
```

```shell
$ go run main.go
Lion breathes
Lion walk
```

در بالا ما یک متغیر با تایپ animal تعریف کردیم :

```go
var a animal
```

سپس ما یک نمونه از ساختار lion را بهش اختصاص دادیم :

```go
a = lion{}
```

اختصاص یک نمونه از ساختار lion به متغیر a که با تایپ lion بود موفقیت آمیز بود زیرا ما برای lion متدهای مورد مربوط animal را که breathe و walk بود پیاده سازی کردیم. این مفهوم کاملا شبیه به ducking typing هستش که در بالا گفتیم. یک شیر می تواند نفش بکشد و راه برود از این رو او یک حیوان است.

{{< hint info >}}

توجه کنید اگر شما متد جدیدی را اضافه یا کم کنید و همچنین اگر تغییر ایجاد کنید باید این تغییرات برروی اشیایی که با اینترفیس شما در ارتباط هست صورت بگیرید.

به عنوان مثال شما اگر به اینترفیس animal یک متد جدیدی اضافه کنید حتما باید برای ساختار lion باید پیاده سازی کنید.
{{< /hint >}}


## اینترفیس ها بطور ضمنی (implicitly) پیاده سازی می شود

برای اینترفیس هیچ حالت صریح (explicit) هنگام تعریف وجود ندارد و همه چی بصورت ضمنی است و تا زمانیکه یک اینترفیس برای یک شی (ساختار) متدهایش پیاده سازی نشود هیچ کاربردی نخواهد داشت.

توجه کنید هیچ حالت صریحی وجود ندارد که بگوید شما تمامی متدهای اینترفیس animal را برای ساختار lion پیاده سازی کردید یا خیر و فقط در زمان کامپایل اگر ایرادی وجود داشته باشد کامپایلر به شما خطا می دهد. و البته IDE هایی مانند: Goland , Vscode به شما هنگام نوشتن کد در خصوص این مورد کمک میکنند قبل از کامپایل متوجه خطاهای مرتبط با پیاده سازی اینترفیس شوید.

خب بزارید یک مثال پیچیده برای اینترفیس animal بزنیم و یک شی (ساختار) دیگر به نام dog اضافه کنیم و متدهای اینترفیس animal را برای این شی پیاده سازی کنیم.

```go
package main

import "fmt"

type animal interface {
    breathe()
    walk()
}

type lion struct {
     age int
}

func (l lion) breathe() {
    fmt.Println("Lion breathes")
}

func (l lion) walk() {
    fmt.Println("Lion walk")
}

type dog struct {
     age int
}

func (l dog) breathe() {
    fmt.Println("Dog breathes")
}

func (l dog) walk() {
    fmt.Println("Dog walk")
}

func main() {
    var a animal
    
    a = lion{age: 10}
    a.breathe()
    a.walk()
  
    a = dog{age: 5}
    a.breathe()
    a.walk()
}
```

```shell
$ go run main.go
Lion breathes
Lion walk
Dog breathes
Dog walk
```

در مثال بالا ما یک ساختار با نام dog تعریف کردیم و سپس متدهای animal را برای ساختار dog پیاده سازی کردیم و در نهایت ساختار dog را به متغیر اینترفیس a اختصاص دادیم. همانطور که میبینیم dog هم همانند lion نفس میکشد و راه می رود.

{{< hint info >}}

توجه کنید در بالا ما برای ۲ تا شی lion و dog یک وجه مشترک به نام animal به همراه رفتار مشترک تعریف کردیم که به اینکار پلی مورفیسم می گویند و یکی از عناوین پرکاربرد در شی گرایی می باشد که در [بخش شی گرایی زبان گو](https://book.gofarsi.ir/chapter-4/oop/go-polymorphism/) بیشتر می پردازیم.
{{< /hint >}}


**دو نکته مهم در خصوص اینترفیس :**

1. اینترفیس ها فقط زمان کامپایل مشخص می شود که برای اشیا به درستی پیاده سازی شده اند یا خیر و اگر فرضا ما برای ساختار lion در کد بالا متد walk را حذف کنیم با خطای زیر رو به رو خواهیم شد :
```go
cannot use lion literal (type lion) as type animal in assignment:
```

2. ورود و خروجی های هر متدی که پیاده سازی می کنید برای اشیا (ساختارها) بستگی به تعریف ضمنی متد داخل اینترفیس دارد و اگر شما متدی را داخل اینترفیس تغییر دهید حتما باید آن متد در اشیایی که قبلا پیاده سازی شده تغییر یابد.

