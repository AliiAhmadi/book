---
title: '3.3 پکیج sync'
slug: go-sync-package
weight: 5003
---

پکیج `sync` یکی از کاربردی ترین پکیج ها در زمینه همزمانی می باشد و یکسری تایپ و توابع برای{{< tooltip text="همگام سازی" note="synchronize" >}} و کنترل دسترسی همزمان به داده مشترک ارائه می دهد. که پرکاربردترین آن ها :

- `Mutex` : با استفاده از این می توانید آن بخش از داده ای که گوروتین ها بطور همزمان قصد دارند دسترسی داشته باشند را می توانید قفل کنید.
- `RWMutex` : با استفاده از این می توانید به چندین گوروتین اجازه خواندن دهید ولی فقط یک گوروتین می تواند بنویسد در یک زمان.
- `WaitGroup`: یک هماهنگ کننده گوروتین می باشد برای اینکه ترتیب عملیات ها در هنگام همزمانی رعایت شود.
- `Once`:  این اجازه می دهد یک تابع حداکثر یک بار اجرا شود.

{{< hint info >}}
توجه کنید که پکیج `sync` فقط و فقط برای مدیریت و همگام سازی دسترسی های گوروتین ها به یک داده مشترک استفاده می شود. 
{{< /hint >}}


## 3.3.1 Mutex

در پکیج `sync` یک تایپ به نام `Mutex` وجود دارد که به شما این امکان را می دهد دسترسی به داده مشترک را  {{< tooltip text="همگام سازی" note="synchronize" >}} کنید. زمانیکه از تایپ Mutex استفاده می کند ۲ حالت دارد Lock یا Unlock. وقتی شما Lock می کند فقط و فقط یک گوروتین می تواند برروی آن بخش از داده کار کند و تا زمانیکه شما Unlock نکنید سایر گوروتین ها نمی توانند دسترسی داشته باشند و تا زمانیکه Unlock صورت گیرد سایر گوروتین ها تلاش می کنند تا بتوانند دسترسی پیدا کنند.

به مثال زیر توجه کنید :

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

var count int

func main() {
	mu := new(sync.Mutex)
	
	go increment(mu)
	go increment(mu)
	go increment(mu)
	go increment(mu)

	time.Sleep(time.Second)
}

func increment(mu *sync.Mutex) {
	mu.Lock()
	defer mu.Unlock()
	count++
	fmt.Printf("Incrementing: %d\n", count)
}
```

```shell
$ go run main.go

Incrementing: 1
Incrementing: 2
Incrementing: 3
Incrementing: 4
```

 ![mutex](../../assets/img/content/chapter3/sync/1.jpg)


در بالا ما یک تابع به نام increment ایجاد کردیم و به عنوان ورودی تایپ Mutex را بصورت پوینتر پاس  دادیم. سپس با استفاده از توابع Lock و Unlock برای افزایش مقدار count یک قفل گذاشتیم.

حال ۴ تا گوروتین داریم که قصد دارند همزمان روی بخش مشترک از حافظه عملیاتی را انجام دهند در اینجا ما با استفاده Mutex جلوی اینکه همزمان دسترسی داشته باشند به اون داده از حافظه را گرفتیم و فقط یک گوروتین می تواند عملیات انجام دهد و تا زمانیکه شما Unlock نکنید سایر گوروتین ها منتظر می مانند.

### 3.3.1.1 سناریوهای استفاده

1. **همگام سازی دسترسی به متغیرهای مشترک:** یک mutex می تواند برای همگام سازی دسترسی به متغیرهای مشترک بین چندین گوروتین استفاده شود. این می تواند در مواردی مفید باشد که چندین گوروتین نیاز به خواندن یا به روز رسانی یک متغیر به طور همزمان دارند.

2. **هماهنگی دسترسی به حالت مشترک:** یک mutex می تواند برای هماهنگ کردن دسترسی به حالت مشترک بین چندین گوروتین استفاده شود. به عنوان مثال، ممکن است از یک mutex استفاده کنید تا اطمینان حاصل کنید که فقط یک گوروتین می تواند یک ساختار داده مشترک را در یک زمان تغییر دهد.

3. **پیاده سازی الگوهای تولیدکننده-مصرف کننده (producer-consumer):** یک mutex می تواند برای پیاده سازی الگوهای تولیدکننده-مصرف کننده استفاده شود، که در آن یک یا چند گوروتین داده تولید می کنند و یک یا چند گوروتین آن را مصرف می کنند. mutex می تواند برای همگام سازی دسترسی به ساختار داده مشترک که داده ها را نگه می دارد استفاده شود.

{{< hint warning >}}
**۲ نکته خیلی مهم**

1. سعی کنید پس از اینکه تابع Lock را فراخوانی میکنید تابع Unlock را داخل defer قرار دهید.
2. زمانیکه قصد دارید Mutex را به عنوان پارامتر ورودی برای توابع تعریف کنید بهتر است از نوع {{< tooltip text="اشاره گر" note="pointer" >}} باشد.
{{< /hint >}}

## 3.3.2 RWMutex

در پکیج `sync` یک تایپ به نام `RWMutex` وجود دارد که عملیات خواندن و نوشتن برروی یک داده مشترک را {{< tooltip text="همگام سازی" note="synchronize" >}} می کند. شما می توانید به چندین گوروتین اجازه خواندن یک داده مشترک را بدهید ولی فقط یک گوروتین می تواند عملیات نوشتن را برروی آن داده مشترک را انجام دهد.

